# Домашнее задание №6

## Вопросы для самоконтроля:

### <font color="green"> Что означает аннотация  Before?</font>
Аннотация @Before обозначает методы, которые будут вызваны перед исполнением тестов. Методы должны быть public void. Здесь обычно размещаются предустановки для теста, в нашем случае это генерация тестовых данных (метод setUpToHexStringData). Можно использовать аннотацию @BeforeClass, которая обозначает методы, которые будут вызваны до создания экземпляра тест-класса; методы должны быть public static void.

### <font color="green">Как в тесте проверить, что метод должен бросить исключение?</font>

Несколько способов проверить, что метод должен бросить исключение в тесте с помощью JUnit:

1. <b>Использование аннотации @Test с параметром expected. </b>

Этот параметр принимает класс исключения, которое ожидается увидеть. Если метод выбросит указанное исключение, то тест пройдёт, иначе провалится. 2
2. <b>Использование метода assertThrows().</b>

Он позволяет более явно и гибко управлять процессом проверки исключений.
Метод принимает два аргумента: класс исключения и лямбда-выражение с вызовом метода. Использование assertThrows() даёт больше гибкости, так как позволяет проверить не только тип исключения, но и его сообщение или другие свойства.
3. <b>Использование подхода try/catch/fail. </b>

В этом случае вручную перехватывается исключение, а если оно не было 
   выброшено, тест проваливается.
### <font color="green">Что такое mock? Spy?</font>
<font color="blue"><b>Mock</b> </font>— это искусственный объект, который притворяется настоящим. Он используется, 
когда нужно 
полностью 
контролировать поведение объекта. Для такого mock сразу после создания характерно поведение по умолчанию (все методы возвращают заранее известные значения). Это поведение можно переопределить желаемым образом.

Чтобы создать mock класса DataService, я должен сделать всего лишь следующее:
```java 
DataService dataServiceMock = Mockito.mock(DataService.class);
```
Готово — я получил экземпляр нужного мне класса.

<font color="blue"><b>Spy</b> </font> — это частичный мок (или шпионы). Он применяется, когда нужно частично подменить 
поведение реального объекта. Поведение 
spy-объектов по умолчанию идентично поведению обычного экземпляра класса, однако их тоже можно переопределять и наблюдать за их использованием.
```java
DataService dataServiceSpy = Mockito.spy(DataService.class);
// or
DataService dataService = new DataService();
dataServiceSpy = Mockito.spy(dataService);
```
---
Таким образом, <b>mock используется, когда нужно протестировать логику самого объекта и при этом не внедрять 
какие-либо реальные сервисы и компоненты, а spy — когда нужно протестировать всё вместе, за исключением каких-то 
специфических случаев.</b>

### <font color="green">Для чего применяется статический метод  Mockito.verify?</font>
Статический метод Mockito.verify применяется для подтверждения определённого взаимодействия с макетными объектами.

Он позволяет убедиться, что методы, которые должны быть вызваны для макетных объектов, действительно вызваны и с правильными параметрами.

С помощью метода Mockito.verify можно проверить, что метод был вызван с определёнными параметрами, количеством раз, когда он вызывался, и так далее.
```java
@Test
public void verifyMethodCall() {
    // Создание мока
    OrderService orderService = Mockito.mock(OrderService.class);

    // Создание тестового заказа
    Order testOrder = new Order("TestItem", 3);

    // Имитация вызова метода
    orderService.placeOrder(testOrder);

    // Верификация: был ли вызван метод placeOrder с testOrder
    Mockito.verify(orderService).placeOrder(testOrder);
}
```
Здесь мы не только создали мок OrderService, но и проверили, что метод placeOrder был вызван с определенным заказом.

```java
@Test
public void verifyNumberOfMethodCalls() {
    OrderService orderService = Mockito.mock(OrderService.class);

    // Имитация вызовов
    orderService.placeOrder(new Order("Item1", 1));
    orderService.placeOrder(new Order("Item2", 2));

    // Верификация: метод placeOrder был вызван дважды
    Mockito.verify(orderService, Mockito.times(2)).placeOrder(Mockito.any(Order.class));

    // Верификация: метод getOrderCount ни разу не был вызван
    Mockito.verify(orderService, Mockito.never()).getOrderCount();
}
```
В этом примере мы проверяем, что placeOrder был вызван ровно два раза с любыми заказами и что getOrderCount не был вызван вообще.

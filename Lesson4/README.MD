# Домашнее задание 4 
## 1 Реализовать интерфейс Terminal, c помощью которого можно:
* Проверить состояние счета
* Снять/ положить деньги  

  Доступ к терминалу (терминал для одного счета) предоставляется только после ввода корректного пин-кода (4 цифры). Каждое нажатие должно восприниматься системой как ввод очередного символа пин-кода.
  При вводе нецифрового символа система должна выдать предупреждение, но при этом данное действие не считается критичной ошибкой ввода и состояние системы должно восстановиться к последнему корректному состоянию.

При вводе 3 неправильных пин-кодов аккаунт блокируется на 10 сек (при попытке обратиться к нему в течение этого времени должно вызываться исключение AccountIsLockedException c информацией об оставшемся времени до снятия блокировки).

Класть и снимать деньги можно только, если сумма кратна 100.

Поскольку банкоматы, установленные на улице, сами «ничего не делают» с вашим счетом (они лишь делают проверку введенных данных и отправляют запросы на удаленный), то сервер (TerminalServer) может вызывать свои исключения, например, при недостатке средств на счете для совершения операции.

Класс терминал может содержать следующие поля:
```java
class TerminalImpl {
private final TerminalServer server;
private final PinValidator pinValidator;
...
}
```

Часть команд терминал делегирует этим классам.

Интерфейс терминала и список исключений остается на ваш дизайн. В каждом ексепшене должно быть описание, что нужно сделать, чтобы избежать его в дальнейшем.

TerminalServer и PinValidator могут кидать свои собственные исключения. Конечный пользователь не должен видеть эти исключения, ему должны показываться человеко-читабельные сообщения об ошибках

Логика по показу сообщений конечному пользователю и бизнес логика терминала с обработкой исключений должна быть в разных классах, чтобы можно было легко менять интрефейс вывода сообщений (на консоль, через графический интерфейс и т.д.)

## 2. Реализуйте метод readContent(String url), который отображает на экран содержимое сайта, ссылка на который задаётся параметром url.

Напишите программу, считывающую из консоли строку (URL ресурса) и вызывающую метод readContent. В том случае, если введённый URL неправильного формата или нет доступа до указанного ресурса, пользователю предлагается повторить ввод.

## 3. Вопросы для самоконтроля:

1. Правильно ли написан следующий код:
```java
try {

} finally {

}
```
</b></details>
<details>

<summary>Ответ</summary>
Да, данный код синтаксически правильный. В конструкции try...finally блок try используется для размещения кода, который может вызывать исключения, а блок finally выполняется в любом случае, независимо от того, произошло ли исключение в блоке try или нет.
</details>

2. Какие исключения могут быть перехвачены следующим обработчиком:

```java
catch (Exception e) {
}
```
Что не так с использованием такого обработчика?
</b></details>
<details>
<summary>Ответ</summary>
Обработчик catch (Exception e) перехватывает все исключения, которые являются подклассами Exception. Это включает в себя:

1. Проверяемые исключения (Checked Exceptions): Исключения, которые должны быть обработаны или объявлены в сигнатуре метода. Например:

   • IOException

   • SQLException

   • ClassNotFoundException

2. Непроверяемые исключения (Unchecked Exceptions): Исключения, которые не требуют обязательной обработки. Они являются подклассами RuntimeException. Например:

   • NullPointerException

   • ArrayIndexOutOfBoundsException

   • IllegalArgumentException

▎Проблемы с использованием такого обработчика:

1. Широкий охват: Перехватывая все исключения, вы можете скрыть ошибки, которые следует обрабатывать отдельно. Это может затруднить диагностику проблем, так как вы не будете знать, какое конкретное исключение произошло.

2. Потеря информации: Если вы просто ловите все исключения и не делаете с ними ничего (например, не логируете их), вы можете потерять важную информацию о причине ошибки.

3. Необработанные исключения: Некоторые исключения, такие как OutOfMemoryError или StackOverflowError, являются серьезными проблемами, которые не должны обрабатываться обычным образом. Их перехват может привести к неожиданному поведению программы.

4. Неясность кода: Использование общего обработчика может сделать код менее понятным. Другие разработчики могут не понимать, какие исключения могут возникнуть и как они должны обрабатываться.

▎Рекомендации:

• Используйте более специфичные обработчики для конкретных типов исключений.

• Обрабатывайте только те исключения, которые вы можете корректно обработать.

• Логируйте или обрабатывайте исключения так, чтобы сохранить информацию о том, что произошло.
</details>

3. Имеется ли ошибка в написании такого обработчика исключения? Скомпилируется ли этот код?
```java
try {
} catch (Exception e) {
} catch (ArithmeticException a) {
}
```
</b></details>
<details>

<summary>Ответ</summary><b>
Да, в этом коде есть ошибка, и он не скомпилируется. </b>

В Java, когда вы используете блок try-catch, порядок обработки исключений имеет значение. Если вы сначала перехватываете более общий класс исключений (в данном случае Exception), то последующие блоки catch, которые перехватывают подклассы этого исключения (такие как ArithmeticException), никогда не будут достигнуты. Это связано с тем, что ArithmeticException является подклассом Exception, и если произойдет любое исключение, производное от Exception, оно будет перехвачено первым блоком catch.

Таким образом, компилятор выдаст ошибку, указывая на то, что блок catch (ArithmeticException a) недостижим.
</details>

4. Сопоставьте каждую ситуацию из первого списка с пунктом второго списка:
    a) int[] A; A[0] = 0;  
    b) JVM начинает запускать вашу программу, но обнаруживает, что не может найти классы Java платформы;  
    c) программа читает входной поток и достигает маркера конца потока;  
    d) после достижения маркера конца входного потока, но до закрытия самого потока, программа пытаться считать 
   данные.  

    1) ошибка;
    2) проверяемое исключение;
    3) ошибка компиляции;
    4) исключение не произойдёт.
       </b></details>
<details>

<summary>Ответ</summary><b>
• a) - 3  

• b) - 1  

• c) - 4  

• d) - 2  

---
a) int[] A; A[0] = 0;
3) ошибка компиляции;  
   Объяснение: В этом коде массив A объявлен, но не инициализирован, что приводит к ошибке компиляции.

---
b) JVM начинает запускать вашу программу, но обнаруживает, что не может найти классы Java платформы;
1) ошибка;  
   Объяснение: Это ситуация, когда JVM не может найти необходимые классы, что приводит к ошибке времени выполнения.

---
c) программа читает входной поток и достигает маркера конца потока;
4) исключение не произойдёт;  
   Объяснение: Достижение конца потока обычно не вызывает исключения, программа просто завершает чтение.

---
d) после достижения маркера конца входного потока, но до закрытия самого потока, программа пытается считать данные.
2) проверяемое исключение;  
   Объяснение: Попытка чтения данных после конца потока может привести к EOFException, которая является проверяемым исключением.
</details>
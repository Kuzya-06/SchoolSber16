# Домашнее задание 24
# Работа с памятью – Java memory model
### Callable в Java
 — это интерфейс для определения задач, которые возвращают результат. 1 Он был введён в Java 5 и представляет собой 
 более универсальный инструмент для работы с потоками.  
Метод call() этого интерфейса возвращает результат и может бросить проверяемое исключение. Это делает Callable 
 подходящим для сложных задач, где требуется обработка исключений и возвращение результата.

## Задание 1.
Ваша задача реализовать класс Task имеющий один метод get():
```java
public class Task<T> {
    public Task(Callable<? extends T> callable) {
        //...
     }
 
    public T get() {
         ….. // todo implement me
    }
}
```
Данный класс в конструкторе принимает экземпляр java.util.concurrent.Callable. Callable похож на Runnuble, но результатом его работы является объект (а не void).

Ваша задача реализовать метод get() который возвращает результат работы Callable. Выполнение callable должен начинать тот поток, который первый вызвал метод get(). Если несколько потоков одновременно вызывают этот метод, то выполнение должно начаться только в одном потоке, а остальные должны ожидать конца выполнения (не нагружая процессор).
Если при вызове get() результат уже просчитан, то он должен вернуться сразу, (даже без задержек на вход в синхронизированную область).
Если при просчете результата произошел Exception, то всем потокам при вызове get(), надо кидать этот Exception, обернутый в ваш RuntimeException (подходящее название своему ексепшену придумайте сами).
---  

---
### CountDownLatch в Java
 — это синхронизационный механизм, который позволяет одному или нескольким потокам ждать, пока другие потоки 
 завершат выполнение своих задач.  
Он предоставляет возможность потокам ожидать завершение определённых операций, выполняемых другими потоками, прежде 
 чем переходить к следующему этапу работы.  

Принцип работы: создаётся объект CountDownLatch с определённым счётчиком, который инициализируется при создании. 
 Затем один или несколько потоков могут уменьшать этот счётчик, вызывая метод countDown(). Другие потоки могут ждать,
 пока счётчик не станет равным нулю, вызывая метод await().  

CountDownLatch подходит для случаев, когда основному потоку необходимо дождаться завершения ряда связанных задач в 
 других потоках, прежде чем продолжить выполнение своих задач.  

## Задание 2.
Ваша задача реализовать интерфейс ExecutionManager
```java
public interface ExecutionManager {
Context execute(Runnable callback, Runnable... tasks);
}
```
Метод execute принимает массив тасков, это задания которые ExecutionManager должен выполнять параллельно (в вашей реализации пусть будет в своем пуле потоков). После завершения всех тасков должен выполниться callback (ровно 1 раз).

Метод execute – это неблокирующий метод, который сразу возвращает объект Context. Context это интерфейс следующего вида:
```java
public interface Context {
    int getCompletedTaskCount();
    int getFailedTaskCount();
    int getInterruptedTaskCount();
    void interrupt();
    boolean isFinished();
}
```

Метод getCompletedTaskCount() возвращает количество тасков, которые на текущий момент успешно выполнились.  
Метод getFailedTaskCount() возвращает количество тасков, при выполнении которых произошел Exception.  
Метод interrupt() отменяет выполнения тасков, которые еще не начали выполняться.  
Метод getInterruptedTaskCount() возвращает количество тасков, которые не были выполены из-за отмены (вызовом 
предыдущего метода).  
Метод isFinished() вернет true, если все таски были выполнены или отменены, false в противном случае.    

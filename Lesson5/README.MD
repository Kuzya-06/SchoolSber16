# Java: Вопросы и Ответы

## <span style="color:green">  1. Почему на любом объекте можно вызвать метод `getClass()`?

Метод `getClass()` определён в классе `Object`, который является базовым для всех классов в Java. Это означает, что
каждый объект в Java неявно наследует этот метод.

Метод `getClass()` возвращает объект класса `Class`, который представляет метаданные класса, к которому принадлежит
объект.

```
Frog frog=new RedFrog();
Class<?extends Frog> aClass=frog.getClass();
```

---

## <span style="color:green">2. Почему на любом классе можно вызвать `.class`?

`.class` — это специальный синтаксис языка Java для получения объекта класса `Class` (метаданных) во время компиляции.
Он не вызывается на экземпляре, а применяется к типу.

**Пример**:

```
Class<String> stringClass=String.class;
```

Причина, почему это возможно, заключается в том, что механизм .class интегрирован в компилятор Java и поддерживается JVM
для управления метаданными классов.

## <span style="color:green">3. В чём отличие динамического прокси от статического?

### Статический прокси:

Создаётся вручную. Мы пишем класс, который реализует интерфейс и делегирует вызовы оригинальному объекту.

### Динамический прокси:

Создаётся в рантайме с использованием java.lang.reflect.Proxy. Мы не пишем отдельный класс, а передаём интерфейсы и
обработчик вызовов (InvocationHandler), который перехватывает методы.

### Преимущества и недостатки:

| Прокси           | Преимущества                                                                                                                                                                                                    | Недостатки                                                                                                                                      |
|------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| **Динамический** | - Позволяет работать с объектами, чьи классы известны только во время выполнения. <br> - Уменьшает количество "ручного" кода. <br> - Универсален: один обработчик можно использовать для множества интерфейсов. | - Производительность ниже, чем у статического. <br> - Работает только с интерфейсами (в классах требуется использование библиотек вроде CGLIB). |
| **Статический**  | - Простота понимания и отладки. <br> - Лучшее время выполнения, поскольку нет необходимости генерировать прокси-объект.                                                                                         | - Требует писать отдельный класс для каждого интерфейса. <br> - Менее гибок: изменения в интерфейсе требуют изменения прокси.                   |

## <span style="color:green">4. Разница между инициализацией через new и статический метод newInstance()?

### Через new:

* Компилятор проверяет корректность вызова конструктора во время компиляции.
* Прост и безопасен для использования.

### Через newInstance():

* Используется через Class.newInstance() или Constructor.newInstance().
* Проверка конструктора производится только в рантайме.
* Может выбросить исключения IllegalAccessException или InstantiationException.

### Разница:

* new безопаснее и легче читается.
* newInstance() полезен, когда класс определяется динамически, например, в рефлексии.

| Важно: С версии Java 9 метод Class.newInstance() устарел. Рекомендуется использовать Constructor.newInstance(). | 
|-----------------------------------------------------------------------------------------------------------------|

## <span style="color:green">5. Можно ли с помощью рефлексии изменить значения полей аннотации?

**Да**, это возможно, хотя и не рекомендуется. Аннотации в Java по умолчанию являются неизменяемыми, но их можно
модифицировать с помощью рефлексии. Это требует доступа к приватному внутреннему полю аннотации.

 ```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Field;
import java.util.Map;

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
    String value();
}

@MyAnnotation(value = "original")
class MyClass {
}

public class Main {
    public static void main(String[] args) throws Exception {
        MyAnnotation annotation = MyClass.class.getAnnotation(MyAnnotation.class);

        Field field = annotation.getClass().getDeclaredField("memberValues");
        field.setAccessible(true);

        Map<String, Object> memberValues = (Map<String, Object>) field.get(annotation);
        memberValues.put("value", "modified");

        System.out.println(annotation.value()); // modified
    }
}
```

### Минусы:

* Нарушает инкапсуляцию.
* JVM может оптимизировать аннотации, и изменения могут не сработать.
* Может сломаться в будущих версиях Java.
